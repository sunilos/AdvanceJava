# सरल TCP सर्वर का कार्यान्वयन (Echo Server)

यह Java प्रोग्राम एक सरल TCP सर्वर को लागू करता है, जिसे Echo सर्वर कहा जाता है, जो क्लाइंट्स से कनेक्शन के लिए प्रतीक्षा करता है। सर्वर कई क्लाइंट्स को अनुक्रमिक रूप से संभाल सकता है। जब कोई क्लाइंट सर्वर को संदेश भेजता है, तो सर्वर उसे एक दोहराए हुए स्वरूप में वापस क्लाइंट को भेजता है। अगर क्लाइंट "Bye" संदेश भेजता है, तो कनेक्शन बंद हो जाता है। सर्वर तब तक चलता रहता है और नए क्लाइंट कनेक्शनों को स्वीकार करता रहता है जब तक कि इसे मैन्युअली बंद न कर दिया जाए।

## कोड के साथ Javadoc और टिप्पणियाँ:
```java
package in.co.sunrays.net;

import java.io.*;
import java.net.*;

/**
 * EchoServer एक TCP सर्वर है जो कई क्लाइंट्स के साथ अनुक्रमिक रूप से संचार करता है।
 * यह क्लाइंट कनेक्शनों के लिए पोर्ट 4444 पर प्रतीक्षा करता है। जब कोई क्लाइंट कनेक्ट होता है,
 * सर्वर क्लाइंट द्वारा भेजे गए संदेशों को वापस भेज देता है।
 * 
 * सर्वर तब तक क्लाइंट अनुरोध स्वीकार करता रहता है जब तक इसे मैन्युअली बंद न कर दिया जाए।
 * यदि कोई क्लाइंट "Bye" भेजता है, तो उस क्लाइंट के साथ कनेक्शन बंद हो जाता है।
 * 
 * @author Sunil
 * @version 1.0
 * @since 2024
 */
public class EchoServer {

    /**
     * मुख्य विधि सर्वर को शुरू करती है, क्लाइंट कनेक्शनों के लिए प्रतीक्षा करती है,
     * और क्लाइंट संचार को अनुक्रमिक रूप से संभालती है। यह मैन्युअल रूप से बंद किए जाने तक चलती रहती है।
     * 
     * @param a कमांड-लाइन तर्क (इस कार्यान्वयन में उपयोग नहीं किए गए)
     * @throws IOException यदि सॉकेट्स को संभालते समय कोई I/O त्रुटि होती है
     */
    public static void main(String[] a) throws IOException {

        // पोर्ट 4444 पर सर्वर शुरू करें
        ServerSocket sSocket = new ServerSocket(4444);

        System.out.println("Echo Server चालू हो गया है");

        // क्लाइंट कनेक्शनों को संभालने के लिए सॉकेट ऑब्जेक्ट
        Socket client = null;

        // सर्वर को चलाते रहने के लिए फ्लैग
        boolean flag = true;

        // जब तक फ्लैग true है तब तक क्लाइंट कनेक्शनों के लिए प्रतीक्षा करें
        while (flag) {
            // नए क्लाइंट अनुरोध को स्वीकार करें और संचार के लिए सॉकेट बनाएँ
            client = sSocket.accept();

            // जुड़े हुए क्लाइंट के साथ संचार को संभालें
            talk(client);
        }

        // जब समाप्त हो जाए तब सर्वर सॉकेट बंद करें
        sSocket.close();

        System.out.println("Echo Server बंद हो गया है");
    }

    /**
     * talk विधि जुड़े हुए क्लाइंट के साथ संचार को संभालती है।
     * यह क्लाइंट द्वारा भेजे गए संदेशों को पढ़ती है, उन्हें वापस भेजती है,
     * और तब तक जारी रहती है जब तक क्लाइंट "Bye" नहीं भेजता।
     * 
     * @param cSocket क्लाइंट के साथ संचार के लिए सॉकेट ऑब्जेक्ट
     * @throws IOException यदि संचार के दौरान कोई I/O त्रुटि होती है
     */
    public static void talk(Socket cSocket) throws IOException {

        // सॉकेट के आउटपुट स्ट्रीम के माध्यम से क्लाइंट को डेटा भेजने के लिए PrintWriter बनाएँ
        PrintWriter out = new PrintWriter(cSocket.getOutputStream(), true);

        // सॉकेट के इनपुट स्ट्रीम के माध्यम से क्लाइंट द्वारा भेजे गए डेटा को पढ़ने के लिए BufferedReader बनाएँ
        BufferedReader in = new BufferedReader(new InputStreamReader(cSocket.getInputStream()));

        // क्लाइंट द्वारा भेजी गई पहली पंक्ति को पढ़ें
        String line = in.readLine();

        // जब तक क्लाइंट "Bye" या null नहीं भेजता तब तक संचार जारी रखें
        while (line != null) {

            // सर्वर कंसोल पर प्राप्त संदेश को प्रिंट करें
            System.out.println("सर्वर ने प्राप्त किया: " + line);

            // संदेश को दोहराए हुए स्वरूप में क्लाइंट को वापस भेजें
            out.println(line + " .. " + line);

            // यदि क्लाइंट "Bye" भेजता है, तो लूप से बाहर निकलें और कनेक्शन बंद करें
            if (line.equals("Bye")) {
                break;
            }

            // क्लाइंट से अगली पंक्ति पढ़ें
            line = in.readLine();
        }

        // आउटपुट और इनपुट स्ट्रीम्स को बंद करें
        out.close();
        in.close();

        // क्लाइंट सॉकेट को बंद करें
        cSocket.close();
    }
}
```

## परिवर्तन का सारांश:
### Javadoc टिप्पणियाँ:
- क्लास स्तर, विधि स्तर और इनलाइन टिप्पणियाँ जोड़ी गई हैं जो कोड की कार्यक्षमता को समझाती हैं।
- क्लास-स्तरीय Javadoc EchoServer क्लास के उद्देश्य और क्लाइंट्स के साथ इसके संचार को स्पष्ट करता है।
- विधि-स्तरीय Javadoc मुख्य() और talk() विधियों का विस्तार से वर्णन करता है।

### अनुक्रमिक क्लाइंट संचार:
- सर्वर ServerSocket का उपयोग करके पोर्ट 4444 पर क्लाइंट कनेक्शनों के लिए प्रतीक्षा करता है।
- जब भी कोई क्लाइंट कनेक्ट होता है, talk() विधि उस विशिष्ट क्लाइंट के साथ संचार को संभालने के लिए कॉल की जाती है।
- सर्वर एक समय में एक क्लाइंट को संभालता है (अनुक्रमिक रूप से), जिसका अर्थ है कि कई क्लाइंट्स एक साथ कनेक्ट और इंटरैक्ट नहीं कर सकते।

### Echo व्यवहार:
- जब कोई क्लाइंट संदेश भेजता है, तो सर्वर उसे अपनी कंसोल पर प्रिंट करता है और संदेश को एक दोहराए हुए स्वरूप में क्लाइंट को वापस भेजता है।
- लूप तब तक चलता है जब तक क्लाइंट "Bye" नहीं भेजता, इस स्थिति में सर्वर उस क्लाइंट के साथ कनेक्शन बंद कर देता है।

### सर्वर का जीवनचक्र:
- जब तक फ्लैग true है, सर्वर क्लाइंट कनेक्शनों को स्वीकार करना जारी रखता है।
- सर्वर सॉकेट को मैन्युअल रूप से बंद किया जाता है जब फ्लैग false होता है (हालांकि इस उदाहरण में इसे false सेट करने के लिए कोई विशेष तंत्र नहीं दिया गया है)।

### अपवाद प्रबंधन:
- प्रोग्राम संभावित IOException को संभालता है ताकि क्लाइंट्स के कनेक्ट या संचार करते समय होने वाली I/O त्रुटियों को ठीक से प्रबंधित किया जा सके।
```
